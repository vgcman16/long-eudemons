using System.Numerics;
using System.Security.Cryptography;
using System.Text;

namespace Long.Network.Security.SRP6
{
    public class Srp6
    {
        #region Modulus(N), salt, generator(g), multiplier(k), Identity Hash
        public BigInteger Modulus
        {
            get;
            private set;
        }

        public BigInteger Salt
        {
            get;
            private set;
        }

        public BigInteger Generator
        {
            get;
            private set;
        }

        public BigInteger Multiplier
        {
            get;
            private set;
        }

        public byte[] IdentityHash
        {
            get;
            private set;
        }
        #endregion

        #region Server calculated properties
        public BigInteger SaltedIdentityHash
        {
            get;
            private set;
        }

        public BigInteger Scrambler
        {
            get;
            private set;
        }

        public BigInteger Verifier
        {
            get;
            private set;
        }
        #endregion

        #region Common properties
        public BigInteger SessionKey
        {
            get;
            private set;
        }

        public BigInteger PrivateKey
        {
            get;
            private set;
        }

        public BigInteger PublicKey
        {
            get;
            private set;
        }

        public bool IsServerInstance
        {
            get;
            private set;
        }
        #endregion

        #region Encryption/Decryption properties
        /// <summary>
        /// The initial vector used for the AES Decrypt/Encrypt methods
        /// </summary>
        public string InitialVector
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the hash algorithm.
        /// </summary>
        public string HashAlgorithm
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the password iterations.
        /// </summary>
        public int PasswordIterations
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets the size of the key.
        /// </summary>
        public int KeySize
        {
            get;
            private set;
        }
        #endregion

        #region Constructors
        private Srp6(string initialVector, string modulus, int generator, byte[] identityHash)
        {
            HashAlgorithm = "SHA1";
            PasswordIterations = 2;
            KeySize = 256;
            InitialVector = initialVector;

            IdentityHash = identityHash;
            Modulus = BigIntegerExtensions.CreateBigInteger(modulus, 16);
            Generator = BigIntegerExtensions.CreateBigInteger("" + generator, 10);
            Multiplier = BigIntegerExtensions.CreateBigInteger("3", 10);
        }

        // Server Constructor, Radix 16 strings, 256-bit predef values
        public Srp6(byte[] identityHash, string modulus, int generator, int saltBits,
            int scramblerBits, string initialVector = "OFRna73m*aze01xY")
            : this(initialVector, modulus, generator, identityHash)
        {
            // This SRP6 instance is a server instance
            IsServerInstance = true;

            // Generate the Salt
            Salt = BigIntegerExtensions.CreateBigInteger(saltBits, new Random());

            // Set the salted identity hash, scrambler, and verifier
            Scrambler = BigIntegerExtensions.CreateBigInteger(scramblerBits, new Random());
            SaltedIdentityHash = Salt.CreateSaltedIdentityHash(identityHash);
            Verifier = Generator.ModPow(SaltedIdentityHash, Modulus);

            // Random 128 bit number that is a probable prime
            PrivateKey = BigIntegerExtensions.GeneratePseudoPrime(128, 100, new Random());

            // kv + g^b  (mod N)
            PublicKey = Multiplier.Multiply(Verifier).Add(Generator.ModPow(PrivateKey, Modulus));
        }

        // Client Constructor, salt not generated by client
        public Srp6(byte[] identityHash, String modulus, int generator,
            String salt, string initialVector = "OFRna73m*aze01xY")
            : this(initialVector, modulus, generator, identityHash)
        {
            // This SRP6 instance is a client instance
            IsServerInstance = false;

            // Convert the salt string to a BigInteger
            Salt = BigIntegerExtensions.CreateBigInteger(salt, 16);

            // Set the salted identity hash
            SaltedIdentityHash = Salt.CreateSaltedIdentityHash(identityHash);

            // Generate a pseudo prime to use for the private key
            PrivateKey = BigIntegerExtensions.GeneratePseudoPrime(128, 100, new Random());

            // g^a (mod N)
            PublicKey = Generator.ModPow(PrivateKey, Modulus);
        }
        #endregion

        #region Set Session Key
        public void SetSessionKey(String pubKeyString, String scrambler = null)
        {
            BigInteger pubKey = BigIntegerExtensions.CreateBigInteger(pubKeyString, 16);
            if (IsServerInstance)       // Server SessionKey
            {
                // (Av^u) ^ b (mod N)
                SessionKey = pubKey.Multiply(Verifier.ModPow(Scrambler, Modulus)).ModPow(PrivateKey, Modulus);
            }
            else                        // Client SessionKey
            {
                Scrambler = BigIntegerExtensions.CreateBigInteger(scrambler, 16);
                BigInteger temp = PrivateKey.Add(Scrambler.Multiply(SaltedIdentityHash));
                SessionKey = pubKey.Subtract((Generator.ModPow(SaltedIdentityHash, Modulus))
                                             .Multiply(Multiplier)).ModPow(temp, Modulus);
            }
        }
        #endregion

        #region Encryption methods
        /// <summary>
        /// Encrypts a string
        /// </summary>
        /// <param name="plainText">Text to be encrypted</param>
        /// <returns>The encrypted string</returns>
        public string Encrypt(string plainText)
        {
            if (string.IsNullOrEmpty(plainText))
                return "";
            var plainTextBytes = Encoding.UTF8.GetBytes(plainText);
            var cipherTextBytes = Encrypt(plainTextBytes);
            return Convert.ToBase64String(cipherTextBytes);
        }

        /// <summary>
        /// Encrypt the specified stream. This should be called in a using statement.
        /// </summary>
        /// <param name='stream'>Stream to encrypt</param>
        /// <returns>An encrypted memory stream</returns>
        public Stream Encrypt(Stream stream)
        {
            var results = new byte[stream.Length];
            stream.Read(results, 0, results.Length);
            byte[] encryptedBytes = Encrypt(results);
            return new MemoryStream(encryptedBytes, false);
        }

        /// <summary>
        /// Encrypt the specified plainTextBytes
        /// </summary>
        /// <param name='plainTextBytes'>Plain text bytes</param>
        /// <returns>Encrypted text bytes</returns>
        public byte[] Encrypt(byte[] plainTextBytes)
        {
            string password = SessionKey.ToHexString();
            string salt = Salt.ToHexString();
            if (plainTextBytes == null)
                return null;
            byte[] initialVectorBytes = Encoding.ASCII.GetBytes(InitialVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(salt);
            var derivedPassword = new PasswordDeriveBytes(password, saltValueBytes, HashAlgorithm, PasswordIterations);
            byte[] keyBytes = derivedPassword.GetBytes(KeySize / 8);
            var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };
            byte[] cipherTextBytes;
            using (var encryptor = symmetricKey.CreateEncryptor(keyBytes, initialVectorBytes))
            {
                using (var memStream = new MemoryStream())
                {
                    using (var cryptoStream = new CryptoStream(memStream, encryptor, CryptoStreamMode.Write))
                    {
                        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
                        cryptoStream.FlushFinalBlock();
                        cipherTextBytes = memStream.ToArray();
                        memStream.Close();
                        cryptoStream.Close();
                    }
                }
            }
            symmetricKey.Clear();
            return cipherTextBytes;
        }
        #endregion

        #region Decryption methods
        /// <summary>
        /// Decrypts a string
        /// </summary>
        /// <param name="cipherText">Text to be decrypted</param>
        /// <returns>The decrypted string</returns>
        public string Decrypt(string cipherText)
        {
            if (string.IsNullOrEmpty(cipherText))
                return "";
            int byteCount;
            byte[] plainTextBytes = Decrypt(Convert.FromBase64String(cipherText), out byteCount);
            return Encoding.UTF8.GetString(plainTextBytes, 0, byteCount);
        }

        /// <summary>
        /// Decrypt the specified stream. This should be called in a using statement.
        /// </summary>
        /// <param name='stream'>Stream to decrypt</param>
        /// <returns>A decrypted memory stream</returns>
        public Stream Decrypt(Stream stream)
        {
            var results = new byte[stream.Length];
            stream.Read(results, 0, results.Length);
            byte[] decryptedBytes = Decrypt(results);
            return new MemoryStream(decryptedBytes, false);
        }

        /// <summary>
        /// Decrypt the specified cipherTextBytes.
        /// </summary>
        /// <param name='cipherTextBytes'>Cipher text bytes</param>
        /// <returns>Decrypted text bytes</returns>
        public byte[] Decrypt(byte[] cipherTextBytes)
        {
            if (cipherTextBytes == null)
                return null;
            int byteCount;
            byte[] decryptedArray = Decrypt(cipherTextBytes, out byteCount);
            return decryptedArray.SubArray(0, byteCount);
        }

        private byte[] Decrypt(byte[] cipherTextBytes, out int byteCount)
        {
            string password = SessionKey.ToHexString();
            string salt = Salt.ToHexString();
            if (cipherTextBytes == null)
            {
                byteCount = 0;
                return null;
            }
            byte[] initialVectorBytes = Encoding.ASCII.GetBytes(InitialVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(salt);
            var derivedPassword = new PasswordDeriveBytes(password, saltValueBytes, HashAlgorithm, PasswordIterations);
            var keyBytes = derivedPassword.GetBytes(KeySize / 8);
            var symmetricKey = new RijndaelManaged { Mode = CipherMode.CBC };
            var plainTextBytes = new byte[cipherTextBytes.Length];
            using (var decryptor = symmetricKey.CreateDecryptor(keyBytes, initialVectorBytes))
            {
                using (var memStream = new MemoryStream(cipherTextBytes))
                {
                    using (var cryptoStream = new CryptoStream(memStream, decryptor, CryptoStreamMode.Read))
                    {

                        byteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
                        memStream.Close();
                        cryptoStream.Close();
                    }
                }
            }
            symmetricKey.Clear();
            return plainTextBytes;
        }
        #endregion
    }
}
